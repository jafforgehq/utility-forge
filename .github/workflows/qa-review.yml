name: QA Review Automation

on:
  repository_dispatch:
    types: [se_pr_ready]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to review"
        required: true
        type: string
      issue_number:
        description: "Issue number linked to the PR"
        required: false
        type: string

permissions:
  actions: write
  contents: write
  pull-requests: write
  issues: write

jobs:
  qa-review:
    runs-on: ubuntu-latest
    env:
      PR_NUMBER: ${{ github.event.client_payload.pr_number || github.event.inputs.pr_number }}
      ISSUE_NUMBER: ${{ github.event.client_payload.issue_number || github.event.inputs.issue_number }}
    steps:
      - name: Ensure input payload exists
        run: |
          if [ -z "${PR_NUMBER}" ]; then
            echo "Missing PR_NUMBER."
            exit 1
          fi

      - name: Wait 15 minutes before QA starts
        run: sleep 900

      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: refs/pull/${{ env.PR_NUMBER }}/head

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run QA test suite
        id: tests
        continue-on-error: true
        run: npm test

      - name: Publish QA report
        if: always()
        uses: actions/github-script@v7
        env:
          TEST_OUTCOME: ${{ steps.tests.outcome }}
          PR_NUMBER: ${{ env.PR_NUMBER }}
          ISSUE_NUMBER: ${{ env.ISSUE_NUMBER }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number(process.env.PR_NUMBER);
            let issueNumber = Number(process.env.ISSUE_NUMBER || 0);
            const testOutcome = process.env.TEST_OUTCOME || "failure";
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const ensureLabel = async (name, color, description) => {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (error) {
                if (error.status !== 404) throw error;
                await github.rest.issues.createLabel({ owner, repo, name, color, description });
              }
            };

            await ensureLabel("role:qa", "6d597a", "Issue owned by QA");
            await ensureLabel("status:qa-review", "ca6702", "Waiting for QA verification");
            await ensureLabel("status:done", "386641", "Completed and merged");

            if (!issueNumber) {
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              const body = pr.data.body || "";
              const match = body.match(/#(\d+)/);
              if (match) {
                issueNumber = Number(match[1]);
              }
            }

            let acceptanceCriteria = [];
            if (issueNumber) {
              const issue = await github.rest.issues.get({
                owner,
                repo,
                issue_number: issueNumber
              });
              const body = issue.data.body || "";
              const section = body.match(/## Acceptance Criteria[\s\S]*?(?:\n## |\n---|$)/i);
              if (section?.[0]) {
                acceptanceCriteria = section[0]
                  .split("\n")
                  .map((line) => line.trim())
                  .filter((line) => line.startsWith("- "));
              }
            }

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100
            });

            const changedFiles = new Set(files.map((file) => file.filename.toLowerCase()));
            const testPatchText = files
              .filter((file) => /(^|\/)test\//.test(file.filename) || /\.test\.(mjs|js|ts|tsx)$/.test(file.filename))
              .map((file) => `${file.filename}\n${file.patch || ""}`)
              .join("\n")
              .toLowerCase();

            const logicPatchText = files
              .filter((file) => /\.js$/.test(file.filename))
              .map((file) => `${file.filename}\n${file.patch || ""}`)
              .join("\n")
              .toLowerCase();

            const fileContains = (fileName, regex) => {
              try {
                const full = path.join(workspace, fileName);
                const text = fs.readFileSync(full, "utf8");
                return regex.test(text);
              } catch {
                return false;
              }
            };

            const hasViewportMeta = files
              .filter((file) => file.filename.toLowerCase().endsWith(".html"))
              .some((file) => fileContains(file.filename, /<meta[^>]+name=["']viewport["'][^>]*>/i));

            const hasResponsiveCss = files
              .filter((file) => file.filename.toLowerCase().endsWith(".css"))
              .some((file) => fileContains(file.filename, /@media\s*\(/i));

            const evaluateCriterion = (criterionText) => {
              const criterion = criterionText.toLowerCase();

              if (criterion.includes("core logic") && criterion.includes("test")) {
                const hasTestsInPr = Array.from(changedFiles).some(
                  (name) => name.startsWith("test/") || name.includes("/test/")
                );
                if (testOutcome === "success" && hasTestsInPr) {
                  return { status: "pass", detail: "Automated tests passed and test files changed." };
                }
                return { status: "fail", detail: "Core-logic test signal is insufficient." };
              }

              if (criterion.includes("readme")) {
                if (changedFiles.has("readme.md")) {
                  return { status: "pass", detail: "README.md changed in this PR." };
                }
                return { status: "fail", detail: "README.md was not updated." };
              }

              if (criterion.includes("input validation")) {
                const hasValidationTests = /(assert\.throws|throws\(|invalid|error)/.test(testPatchText);
                const hasValidationLogic = /(throw new error|invalid|empty|input cannot)/.test(
                  logicPatchText
                );
                if (hasValidationTests && hasValidationLogic) {
                  return {
                    status: "pass",
                    detail: "Validation assertions and error-handling logic were detected."
                  };
                }
                return {
                  status: "fail",
                  detail: "Input validation signal is incomplete in tests or logic."
                };
              }

              if (
                criterion.includes("mobile") ||
                criterion.includes("desktop") ||
                criterion.includes("responsive")
              ) {
                if (hasViewportMeta && hasResponsiveCss) {
                  return {
                    status: "pass",
                    detail: "Viewport meta and responsive CSS media query were detected."
                  };
                }
                return {
                  status: "fail",
                  detail: "Responsive signal missing (expected viewport meta + CSS media query)."
                };
              }

              return {
                status: "fail",
                detail: "No automatic acceptance matcher configured for this criterion."
              };
            };

            const criterionResults = acceptanceCriteria.map((line) => {
              const text = line.slice(2).trim();
              return {
                criterion: text,
                ...evaluateCriterion(text)
              };
            });

            const hasCriteria = acceptanceCriteria.length > 0;
            const hasFail = criterionResults.some((item) => item.status === "fail");
            let qaPass = testOutcome === "success" && hasCriteria && !hasFail;

            const acceptanceSummary = hasCriteria
              ? criterionResults
                  .map(
                    (item) =>
                      `- ${item.status.toUpperCase()}: ${item.criterion} (${item.detail})`
                  )
                  .join("\n")
              : "- FAIL: Acceptance criteria were not parsed from the linked issue.";

            let mergeStatus = "not-attempted";
            let mergeDetail = "QA did not pass, so auto-merge was skipped.";
            let deployStatus = "skipped";
            let deployDetail = "Deployment dispatch was skipped because merge did not happen.";

            if (qaPass) {
              try {
                const pr = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: prNumber
                });

                if (pr.data.merged) {
                  mergeStatus = "already-merged";
                  mergeDetail = "PR was already merged before this QA run.";
                } else if (pr.data.state !== "open") {
                  qaPass = false;
                  mergeStatus = "failed";
                  mergeDetail = `PR is not open (state: ${pr.data.state}).`;
                } else {
                  await github.rest.pulls.merge({
                    owner,
                    repo,
                    pull_number: prNumber,
                    merge_method: "squash",
                    commit_title: `[QA] Auto-merge PR #${prNumber}`
                  });
                  mergeStatus = "merged";
                  mergeDetail = "PR merged automatically after QA pass.";
                }
              } catch (error) {
                qaPass = false;
                mergeStatus = "failed";
                mergeDetail = `Auto-merge failed: ${error.message}`;
              }
            }

            if (qaPass) {
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner,
                  repo,
                  workflow_id: "pages.yml",
                  ref: "main"
                });
                deployStatus = "dispatched";
                deployDetail = "GitHub Pages deployment workflow was dispatched.";
              } catch (error) {
                qaPass = false;
                deployStatus = "failed";
                deployDetail = `Pages dispatch failed: ${error.message}`;
              }
            }

            const qaDecision = qaPass ? "PASS" : "FAIL";

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: [
                "## QA Review Report",
                `Decision: **${qaDecision}**`,
                `Automated tests: **${testOutcome}**`,
                "",
                "### Acceptance criteria status",
                acceptanceSummary,
                "",
                "### Auto-merge status",
                `- ${mergeStatus.toUpperCase()}: ${mergeDetail}`,
                "",
                "### Deploy status",
                `- ${deployStatus.toUpperCase()}: ${deployDetail}`,
                "",
                qaPass
                  ? "QA automation marked this change complete."
                  : "QA automation blocked completion because tests/criteria/merge failed."
              ].join("\n")
            });

            const prIssue = await github.rest.issues.get({
              owner,
              repo,
              issue_number: prNumber
            });
            const prLabelNames = prIssue.data.labels.map((label) =>
              typeof label === "string" ? label : label.name
            );

            if (qaPass) {
              const updatedPrLabels = Array.from(
                new Set([
                  ...prLabelNames.filter((name) => name !== "status:qa-review" && name !== "status:in-progress"),
                  "status:done",
                  "role:qa"
                ])
              );
              await github.rest.issues.setLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: updatedPrLabels
              });
            } else {
              const updatedPrLabels = Array.from(
                new Set([
                  ...prLabelNames.filter((name) => name !== "status:done"),
                  "status:qa-review",
                  "role:qa"
                ])
              );
              await github.rest.issues.setLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: updatedPrLabels
              });
            }

            if (issueNumber && qaPass) {
              const issue = await github.rest.issues.get({
                owner,
                repo,
                issue_number: issueNumber
              });
              const names = issue.data.labels.map((label) =>
                typeof label === "string" ? label : label.name
              );
              const updated = Array.from(
                new Set([
                  ...names.filter(
                    (name) => name !== "status:qa-review" && name !== "status:in-progress"
                  ),
                  "status:done",
                  "role:qa"
                ])
              );
              await github.rest.issues.setLabels({
                owner,
                repo,
                issue_number: issueNumber,
                labels: updated
              });

              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                state: "closed",
                state_reason: "completed"
              });
            }

            if (!qaPass) {
              core.setFailed(
                "QA automation failed because tests, criteria matching, or auto-merge did not pass."
              );
            }
