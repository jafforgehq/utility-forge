name: QA Review Automation

on:
  repository_dispatch:
    types: [se_pr_ready]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to review"
        required: true
        type: string
      issue_number:
        description: "Issue number linked to the PR"
        required: false
        type: string

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  qa-review:
    runs-on: ubuntu-latest
    env:
      PR_NUMBER: ${{ github.event.client_payload.pr_number || github.event.inputs.pr_number }}
      ISSUE_NUMBER: ${{ github.event.client_payload.issue_number || github.event.inputs.issue_number }}
    steps:
      - name: Ensure input payload exists
        run: |
          if [ -z "${PR_NUMBER}" ]; then
            echo "Missing PR_NUMBER."
            exit 1
          fi

      - name: Wait 15 minutes before QA starts
        run: sleep 900

      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: refs/pull/${{ env.PR_NUMBER }}/head

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run QA test suite
        id: tests
        continue-on-error: true
        run: npm test

      - name: Publish QA report
        if: always()
        uses: actions/github-script@v7
        env:
          TEST_OUTCOME: ${{ steps.tests.outcome }}
          PR_NUMBER: ${{ env.PR_NUMBER }}
          ISSUE_NUMBER: ${{ env.ISSUE_NUMBER }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number(process.env.PR_NUMBER);
            let issueNumber = Number(process.env.ISSUE_NUMBER || 0);
            const testOutcome = process.env.TEST_OUTCOME || "failure";
            const ensureLabel = async (name, color, description) => {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (error) {
                if (error.status !== 404) throw error;
                await github.rest.issues.createLabel({ owner, repo, name, color, description });
              }
            };

            await ensureLabel("role:qa", "6d597a", "Issue owned by QA");
            await ensureLabel("status:qa-review", "ca6702", "Waiting for QA verification");
            await ensureLabel("status:done", "386641", "Completed and merged");

            if (!issueNumber) {
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              const body = pr.data.body || "";
              const match = body.match(/#(\d+)/);
              if (match) {
                issueNumber = Number(match[1]);
              }
            }

            let acceptanceCriteria = [];
            if (issueNumber) {
              const issue = await github.rest.issues.get({
                owner,
                repo,
                issue_number: issueNumber
              });
              const body = issue.data.body || "";
              const section = body.match(/## Acceptance Criteria[\s\S]*?(?:\n## |\n---|$)/i);
              if (section?.[0]) {
                acceptanceCriteria = section[0]
                  .split("\n")
                  .map((line) => line.trim())
                  .filter((line) => line.startsWith("- "));
              }
            }

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100
            });

            const changedFiles = new Set(files.map((file) => file.filename.toLowerCase()));
            const testPatchText = files
              .filter((file) => /(^|\/)test\//.test(file.filename) || /\.test\.(mjs|js|ts|tsx)$/.test(file.filename))
              .map((file) => `${file.filename}\n${file.patch || ""}`)
              .join("\n")
              .toLowerCase();

            const evaluateCriterion = (criterionText) => {
              const criterion = criterionText.toLowerCase();

              if (criterion.includes("core logic") && criterion.includes("test")) {
                const hasTestsInPr = Array.from(changedFiles).some(
                  (name) => name.startsWith("test/") || name.includes("/test/")
                );
                if (testOutcome === "success" && hasTestsInPr) {
                  return { status: "pass", detail: "Automated tests passed and test files changed." };
                }
                return { status: "fail", detail: "Core-logic test signal is insufficient." };
              }

              if (criterion.includes("readme")) {
                if (changedFiles.has("readme.md")) {
                  return { status: "pass", detail: "README.md changed in this PR." };
                }
                return { status: "fail", detail: "README.md was not updated." };
              }

              if (criterion.includes("input validation")) {
                if (/(assert\.throws|throws\(|invalid|error)/.test(testPatchText)) {
                  return { status: "pass", detail: "Validation/error assertions were found in tests." };
                }
                return {
                  status: "fail",
                  detail: "Input-validation assertions were not detected in PR tests."
                };
              }

              if (
                criterion.includes("mobile") ||
                criterion.includes("desktop") ||
                criterion.includes("responsive")
              ) {
                return {
                  status: "unmatched",
                  detail: "Requires manual UI verification; no automatic matcher configured."
                };
              }

              return {
                status: "unmatched",
                detail: "No automatic acceptance matcher configured for this criterion."
              };
            };

            const criterionResults = acceptanceCriteria.map((line) => {
              const text = line.slice(2).trim();
              return {
                criterion: text,
                ...evaluateCriterion(text)
              };
            });

            const hasCriteria = acceptanceCriteria.length > 0;
            const hasFail = criterionResults.some((item) => item.status === "fail");
            const hasUnmatched = criterionResults.some((item) => item.status === "unmatched");

            const pass = testOutcome === "success" && hasCriteria && !hasFail && !hasUnmatched;
            const qaDecision = pass ? "PASS" : "FAIL";

            const acceptanceSummary = hasCriteria
              ? criterionResults
                  .map(
                    (item) =>
                      `- ${item.status.toUpperCase()}: ${item.criterion} (${item.detail})`
                  )
                  .join("\n")
              : "- FAIL: Acceptance criteria were not parsed from the linked issue.";

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: [
                "## QA Review Report",
                `Decision: **${qaDecision}**`,
                `Automated tests: **${testOutcome}**`,
                "",
                "### Acceptance criteria status",
                acceptanceSummary,
                "",
                pass
                  ? "QA automation marked this change as ready to merge."
                  : "QA automation blocked merge because criteria parsing/matching or tests failed."
              ].join("\n")
            });

            if (issueNumber && pass) {
              const issue = await github.rest.issues.get({
                owner,
                repo,
                issue_number: issueNumber
              });
              const names = issue.data.labels.map((label) =>
                typeof label === "string" ? label : label.name
              );
              const updated = Array.from(
                new Set([
                  ...names.filter(
                    (name) => name !== "status:qa-review" && name !== "status:in-progress"
                  ),
                  "status:done",
                  "role:qa"
                ])
              );
              await github.rest.issues.setLabels({
                owner,
                repo,
                issue_number: issueNumber,
                labels: updated
              });
            }

            if (pass) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ["status:done", "role:qa"]
              });
            } else {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ["status:qa-review", "role:qa"]
              });
              core.setFailed(
                "QA automation failed because tests failed or acceptance criteria were not fully parsed/matched."
              );
            }
